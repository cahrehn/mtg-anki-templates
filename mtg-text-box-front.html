<div class="card-container">
    <img class="card-image">
    <div style="display: none;">{{Front}}</div> 
    <canvas id="rules" class="occlusion"></canvas>
</div>

<script>
var url = 'https://api.scryfall.com/cards/'+ "{{UUID}}" + '?format=json';


fetch(url)
    .then(response => response.json())
    .then(data => {
          createCard(data);
    })
    .catch(error => {
      console.error('Error:', error);
    });

function createCard(data) {
    setCardImage(data);
    setOcclusions(data);
}

function setCardImage(data) {
    document.querySelector('.card-image').src = data.image_uris.normal;
}

function setOcclusions(data) {
    const canvases = getCanvases();
    const canvasContexts = getCanvasContexts(canvases);

    setColor(canvases, canvasContexts, data);
    setRulesOcclusion(canvasContexts.rules, data.layout);
}

function sortColorsByWUBRG(colors) {
    const wubrgOrder = ['W', 'U', 'B', 'R', 'G'];
    return colors.slice().sort((a, b) => {
        return wubrgOrder.indexOf(a) - wubrgOrder.indexOf(b);
    });
}

function getOcclusionRectangle(layout) {
    if (layout === "saga") {
        return { x: 14, y: 17, width: 134, height: 109 };
    } else {
        return { x: 24, y: 95, width: 250, height: 43 };
    }
}

function getFillStyle(context, data) {
    const rect = getOcclusionRectangle(data.layout);

    if (data.layout !== "saga" && data.color_identity.length === 2) {
        const sortedColors = sortColorsByWUBRG(data.color_identity);
        const gradient = context.createLinearGradient(rect.x, 0, rect.x + rect.width, 0);
        gradient.addColorStop(0, getMtgColor(sortedColors[0]));
        gradient.addColorStop(0.45, getMtgColor(sortedColors[0]));
        gradient.addColorStop(0.55, getMtgColor(sortedColors[1]));
        gradient.addColorStop(1, getMtgColor(sortedColors[1]));

        return gradient;
    } else {
        return getBackgroundColor(data.color_identity);
    }
}

function setColor(canvases, contexts, data) {
    for (let key in contexts) {
        if (canvases.hasOwnProperty(key) && contexts[key]) {
            const context = contexts[key];
            context.fillStyle = getFillStyle(context, data);
        }
    }
}

function setRulesOcclusion(context, layout) {
    if (context) {
        const rect = getOcclusionRectangle(layout);
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
    }
}

function getCanvases() {
    return {
        "rules": document.getElementById('rules')
    }
}

function getCanvasContexts(canvases) {
    return {
        "rules": canvases.rules ? canvases.rules.getContext('2d') : ''
    }
}

function getBackgroundColor(colors) {
    console.log(colors);
    if (colors.length <= 1) {
        return getMtgColor(colors[0]);
    } else {
        return 'rgb(218, 165, 32)';
    }
}

function getMtgColor(color_identity) {
    let background_color;
    
    switch (color_identity) {
        case 'W':
            background_color = 'rgb(248, 231, 185)'; // Light yellow
            break;
        case 'U':
            background_color = 'rgb(179, 206, 234)'; // Light blue
            break;
        case 'B':
            background_color = 'rgb(166, 159, 157)'; // Dark gray
            break;
        case 'R':
            background_color = 'rgb(235, 159, 130)'; // Light red
            break;
        case 'G':
            background_color = 'rgb(166, 211, 182)'; // Light green
            break;
        default:
            background_color = 'rgb(201, 194, 186)'; // Light brown (for colorless/artifacts)
    }
    
    return background_color;
}
</script>