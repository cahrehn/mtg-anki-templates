<div class="card-container">
    <img class="card-image">
    <div style="display: none;">{{Front}}</div> 
    <canvas id="rules" class="occlusion"></canvas>
</div>

<script>
var url = 'https://api.scryfall.com/cards/'+ "{{UUID}}" + '?format=json';


fetch(url)
    .then(response => response.json())
    .then(data => {
          createCard(data);
    })
    .catch(error => {
      console.error('Error:', error);
    });

function createCard(data) {
    setCardImage(data);
    setOcclusions(data);
}

function setCardImage(data) {
    document.querySelector('.card-image').src = data.image_uris.normal;
}

function setOcclusions(data) {
    const canvases = getCanvases();
    const canvasContexts = getCanvasContexts(canvases);

    setColor(canvases, canvasContexts, data.color_identity, data.layout);
    setRulesOcclusion(canvasContexts.rules, data);
}

function sortColorsByWUBRG(colors) {
    const wubrgOrder = ['W', 'U', 'B', 'R', 'G'];
    return colors.slice().sort((a, b) => {
        return wubrgOrder.indexOf(a) - wubrgOrder.indexOf(b);
    });
}

function setColor(canvases, contexts, color_identity, layout) {
    // Get rectangle dimensions based on layout
    let rectX, rectWidth;
    if (layout === "saga") {
        rectX = 14;
        rectWidth = 134;
    } else {
        rectX = 24;
        rectWidth = 250;
    }

    for (let key in contexts) {
        if (canvases.hasOwnProperty(key) && contexts[key]) {
            const context = contexts[key];

            // Check if this is a two-color card
            if (color_identity.length === 2) {
                // Sort colors by WUBRG order
                const sortedColors = sortColorsByWUBRG(color_identity);

                // Create horizontal gradient
                const gradient = context.createLinearGradient(rectX, 0, rectX + rectWidth, 0);

                // Add color stops: left color -> gradient in middle -> right color
                gradient.addColorStop(0, getMtgColor(sortedColors[0]));
                gradient.addColorStop(0.45, getMtgColor(sortedColors[0]));
                gradient.addColorStop(0.55, getMtgColor(sortedColors[1]));
                gradient.addColorStop(1, getMtgColor(sortedColors[1]));

                context.fillStyle = gradient;
            } else {
                // Single color or 3+ colors
                const backgroundColor = getBackgroundColor(color_identity);
                context.fillStyle = backgroundColor;
            }
        }
    }
}

function setRulesOcclusion(context, data) {
    if (context) {
        if (data.layout === "saga") {
            context.fillRect(14, 17, 134, 109);
        } else {
            context.fillRect(24, 95, 250, 43);
        }
    }
}

function getCanvases() {
    return {
        "rules": document.getElementById('rules')
    }
}

function getCanvasContexts(canvases) {
    return {
        "rules": canvases.rules ? canvases.rules.getContext('2d') : ''
    }
}

function getBackgroundColor(colors) {
    console.log(colors);
    if (colors.length <= 1) {
        return getMtgColor(colors[0]);
    } else {
        // For 3+ colors, you might want to return a specific multi-color background
        return 'rgb(218, 165, 32)'; // Gold color for multi-color cards
    }
}

function getMtgColor(color_identity) {
    let background_color;
    
    switch (color_identity) {
        case 'W':
            background_color = 'rgb(248, 231, 185)'; // Light yellow
            break;
        case 'U':
            background_color = 'rgb(179, 206, 234)'; // Light blue
            break;
        case 'B':
            background_color = 'rgb(166, 159, 157)'; // Dark gray
            break;
        case 'R':
            background_color = 'rgb(235, 159, 130)'; // Light red
            break;
        case 'G':
            background_color = 'rgb(166, 211, 182)'; // Light green
            break;
        default:
            background_color = 'rgb(201, 194, 186)'; // Light brown (for colorless/artifacts)
    }
    
    return background_color;
}
</script>